# -*- coding: utf-8 -*-
"""Gen-Permutations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_d8ty3TPUhEeGRyLqkLoaaOcMGH-6N5Q
"""

import numpy as np

k = 6
L = 32

# k*k wires comes from PE(x,y) blocks in column major order => PE(1,1), PE(2,1) ...
def get_permutation(k, func_for_CNU_num, state = 0):
    res = [[] for _ in range(k)]
    for i in range(k*k):
        curr_CNU_num = func_for_CNU_num(i%k, i//k, state, k)
        res[curr_CNU_num].append(i)

    return [x for elem in res for x in elem]

# x,y,t all should be 0 indexed
def calc_CNU_pi_1(x, y, t, k):
    return x

def calc_CNU_pi_2(x, y, t, k):
    return k-1-y

def build_CNU_pi_3(L, sx, sy, Rx_arr, Cy_arr):
    ### TODO: calc_CNU_pi_3 function for find which CNU will PE(x,y) go at time t
    L, sx, sy, Rx_arr, Cy_arr = L, sx, sy, Rx_arr, Cy_arr

    def calc_CNU_pi_3(x, y, t, k):
        curr_sx = sx[t][x]
        if curr_sx == 1 : curr_Row_perm = Rx_arr[x]
        else            : curr_Row_perm = np.arange(k)

        new_y = np.where(curr_Row_perm == y)
        new_y = new_y[0][0]
        
        curr_sy =  sy[t][new_y]
        if curr_sy == 1 : curr_Col_perm = Cy_arr[new_y]
        else            : curr_Col_perm = np.arange(k)

        new_x = np.where(curr_Col_perm == x)
        new_x = new_x[0][0]
        
        return new_x

    return calc_CNU_pi_3

# generating H3 matrix

# sx, sy for H3
sx = np.random.choice(a=[0, 1], size=(L, k), p=[0.5, 0.5])
sy = np.random.choice(a=[0, 1], size=(L, k), p=[0.5, 0.5])

row_permutations = np.array([np.random.permutation(k) for i in range(k)])  # permutations
col_permutations = np.array([np.random.permutation(k) for i in range(k)])  # permutations

calc_CNU_pi_3 = build_CNU_pi_3(L, sx, sy, row_permutations, col_permutations)

def get_body_statements_permutation_3(args: dict, func_for_CNU_num, unshuffle:bool =False):
    k, L = args['k'], args['L']
    
    statements = []
    # Local reg for mantaining state
    statements.append(f"reg [{int(np.log2(L))-1} : 0] state;")

    # Upate state
    statements.append("always @(posedge clk) begin")
    statements.append("if(reset==1'b0)")
    statements.append("    state <= START_STATE;")
    statements.append("else")
    statements.append("    state <= state + 1;")
    statements.append("end\n")
    
    # Start the combinational always block
    statements.append("always @(*) begin")

    # Make assign statements for each state
    for curr_state in range(L):
      if(curr_state == 0):
        statements.append(f"if (state == {curr_state}) begin\n")
      else:
        statements.append(f"else if (state == {curr_state}) begin\n")
        
      perm = get_permutation(k, func_for_CNU_num, curr_state)
      for i in range(k*k):
        if unshuffle == False:  statement = f"data_out[{i}] <= data_in[{perm[i]}];"
        else:                   statement = f"data_out[{perm[i]}] <= data_in[{i}];"
        statements.append(statement)

      statements.append("end\n")
    
    # End the always block
    statements.append("end")

    return statements

def get_body_statements_permutation(args: dict, func_for_CNU_num, unshuffle:bool =False):
    k = args['k']
    perm = get_permutation(k, func_for_CNU_num)
    
    # Make assign statements
    statements = []
    for i in range(k*k):
      if unshuffle == False:  statement = f"assign data_out[{i}] = data_in[{perm[i]}];"
      else                 :  statement = f"assign data_out[{perm[i]}] = data_in[{i}];"
      statements.append(statement)
    
    return statements

def write_verilog_module(filename: str, args: dict):
    """
    Function used for writing the permutations verilog module to the provided filename
    using the arguments provided.
    """
    
    # Print header to tell this is a python generated file
    module_str = "// This file is generated from a python script, do not edit it by hand.\n\n"
    
    
    # Print comments on top
    module_str += f"/*\n {args['top_comments']} \n*/\n\n"
    
    
    # Writing module name
    module_str += f"module {args['name']}"
    
    
    # Writing module params
    module_parameters = args['params']
    module_str += " #(\n     parameter "
    param_strs = []
    for param, default_val in module_parameters.items():
        param_strs.append(param + " = " + str(default_val))
    
    module_str += ',\n    parameter '.join(param_strs)
    module_str += '\n)\n'
    
    
    # Writing ports of the module
    module_ports = args['ports']
    ports_strs = []
    for port in module_ports:
        curr_port_str = ' '.join([port['io_type'], port['port_type']])
                        
        if(port['multibit'] == True):
            curr_port_str += ' [' + str(port['bit_length']) + '-1 : 0]'
                                
        curr_port_str += (' ' + port['name'])
        if(port["is_array"] == True):
            curr_port_str += ' [0 : ' + str(port['array_len']) + '-1]'
                                  
        ports_strs.append(curr_port_str)
    
    module_str += "(\n    "
    module_str += ',\n    '.join(ports_strs)
    module_str += "\n);\n\n"
    
    
    # Writing body statements
    statements = args['statements']
    module_str += '\n'.join(statements)
    module_str += '\n'
    
    # Ending the module
    module_str += "\nendmodule"
    

    # Finally writing complete module string to the file
    file = open(filename, 'w')
    file.write(module_str)
    file.close()

write_verilog_module("PI_1_shuffle.v", {
    "name": "PI_1_shuffle",
    
    "top_comments": "Inputs from PE (x,y) in column_major order => PE (1, 1), PE(2, 1), ...",
    
    "params": {
        "DATA_WIDTH": 6,
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation({'k': k}, calc_CNU_pi_1, unshuffle=False)
})

write_verilog_module("PI_1_unshuffle.v", {
    "name": "PI_1_unshuffle",
    
    "top_comments": "Inputs from CNU and unshuffled to PE blocks",
    
    "params": {
        "DATA_WIDTH": 6,
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation({'k': k}, calc_CNU_pi_1, unshuffle=True)
})

write_verilog_module("PI_2_shuffle.v", {
    "name": "PI_2_shuffle",
    
    "top_comments": "Inputs from PE (x,y) in column_major order => PE (1, 1), PE(2, 1), ...",
    
    "params": {
        "DATA_WIDTH": 6,
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation({'k': k}, calc_CNU_pi_2, unshuffle=False)
})

write_verilog_module("PI_2_unshuffle.v", {
    "name": "PI_2_unshuffle",
    
    "top_comments": "Inputs from CNU and unshuffled to PE blocks",
    
    "params": {
        "DATA_WIDTH": 6,
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation({'k': k}, calc_CNU_pi_2, unshuffle=True)
})

write_verilog_module("PI_3_shuffle.v", {
    "name": "PI_3_shuffle",
    
    "top_comments": "Inputs from PE (x,y) in column_major order => PE (1, 1), PE(2, 1), ...",
    
    "params": {
        "DATA_WIDTH": 6,
        "START_STATE": 0
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "clk",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : False,
        "is_array"   : False
    },
    {
        "name"       : "reset",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : False,
        "is_array"   : False
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "reg",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation_3({'k': k, 'L': L}, calc_CNU_pi_3, unshuffle=False)
})

write_verilog_module("PI_3_unshuffle.v", {
    "name": "PI_3_unshuffle",
    
    "top_comments": "Inputs from CNU and unshuffled to PE blocks",
    
    "params": {
        "DATA_WIDTH": 6,
        "START_STATE": 3
    },
    
    "ports": [{
        "name"       : "data_in",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    },
    {
        "name"       : "clk",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : False,
        "is_array"   : False
    },
    {
        "name"       : "reset",
        "io_type"    : "input",
        "port_type"  : "wire",
        "multibit"   : False,
        "is_array"   : False
    },
    {
        "name"       : "data_out",
        "io_type"    : "output",
        "port_type"  : "reg",
        "multibit"   : True,
        "bit_length" : "DATA_WIDTH",
        "is_array"   : True,
        "array_len"  : k*k
    }],
    
    "statements": get_body_statements_permutation_3({'k': k, 'L': L}, calc_CNU_pi_3, unshuffle=True)
})

"""# Find Parity check matrix from AG and permutations"""

import numpy as np
import sys

np.set_printoptions(threshold=np.inf, linewidth=np.inf)

"""
@param k                : Number of variables handled by one Check node, num_of_PE_block = k*k
@param L                : Number of actual check (variable) nodes inside CNU (VNU)
@param AG_start_list    : 2d array containing start value of Address Generator for each PE block
@param calc_CNU         : function to calculate the CNU of PE_(x,y) (x, y, CNU_number all are 0-indexed) at time t
@param sx               : 2d binary vector of whether to select a perticular row permutation or used Id instead
@param sy               : 2d binary vector of whether to select a perticular col permutation or used Id instead
"""
def find_H(k:int, L:int, AG_start_list: np.ndarray, calc_CNU: np.ndarray):
    res = np.zeros(shape=(L*k, L*k*k), dtype=int)
    for i in range(L):
        for x in range(k):
            for y in range(k):
                curr_start_pos = (AG_start_list[x,y] + i)%L
                CNU_pos = calc_CNU(x,y,i,k)
                res[CNU_pos*L + i, (y*k + x)*L + curr_start_pos] = 1
                
    return res

# example usage, should generate H1 matrix
AG_start_list    = np.zeros((k,k), dtype=int)
H1 = find_H(k, L, AG_start_list, calc_CNU_pi_1)

# example usage, should generate H2 matrix
# start list for H2
AG_start_list = np.zeros((k,k), dtype=int)
for x in range(k):
  for y in range(k):
    AG_start_list[x,y] = (x*(y+1))%L  # As (x,y) are zero indexed

H2 = find_H(k, L, AG_start_list, calc_CNU_pi_2)

# generating H3 matrix

# Start list for H3
AG_start_list = np.zeros((k,k), dtype=int)

# Not random but satisifes the constraints and works for L>=32
for x in range(k):
  for y in range(k):
    AG_start_list[x, y] = ((x+1)*(y+2))%L

# Will be run using the below call
H3 = find_H(k, L, AG_start_list, calc_CNU_pi_3)

H = np.vstack((H1, H2, H3))

np.save('H_np_array.npy', H) # save

